---
title: "Divorce Rate in 2011 United Kingdom"
author: "Team M"

date: "October 11, 2017"
output: pdf_document

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

# Introduction

Marriage is such a big topic in human life and always a very strong predictor of people's life satisfaction and happiness level. However, not all marriages are eternal happy endings and a lot of them nowadays end in divorce. If we can understand the factors that influence the quality of marriage, we may be able to discover more preventive measures to help more people maintain a lifelong happy marriage.

To answer this question, our group examined the 2011 UK Census data and limited our scope to the marital status of a sample of British people. 

through descriptive and inferential statistics

To clarify, we define divorce rate here as (total number of divorce or separated)/(total number of marriage). Thus, we exclude all people who have not yet married, and the people who end their marriages out of other reasons such as the other partner's death.  



## Description
The dataset we examined is the 5% sample data of the 2011 UK Census. It contains 2,848,155 observations and 121 variables. Each observation represents a UK citizen
Since the dataset is very large and there are too many variables, we decided to exclusively focus on the relationship between marital status (marstat) and other variables. In brief, we would like to examine the factors that may influence people's marriage and lead to higher divorce rate. Therefore, we selected a total of 17 variables that may be highly correlated with marital status.


We can attach a table of all variables we examined here:


# Methods 
a really brief description of the R packages we used. We can load all our libraries in this page:
```{r result = "hide", message=FALSE}
library(dplyr)
library(ggplot2)
library(stargazer)
library(readr)
library(RCurl)
library(foreign)


# Load data
url <- "https://raw.githubusercontent.com/dlouhasha/TheGreatWork/master/data/filtered_dataset.csv"
filtered_data <- getURL(url)
filtered_data <- read.csv(textConnection(filtered_data))

fd <- filtered_data
fd <- as.data.frame(fd)

```


```{r, echo = FALSE}
# changing the factor names 
fd[, 'region'] <- factor(fd[,'region'], levels = c(1, 2, 3, 4, 5, 6, 7,
                                                       8, 9, 10, 11), 
                           labels = c('North East', 'North West', 'Yorkshire and the Humber', 
                                      'East Midlands', 'West Midlands', 'East of England', 
                                      'Inner London',
                                      'Outer London', 'South East', 'South West', 'Wales'))

fd <- fd %>% mutate('binary_region_num' = ifelse(region == 'Inner London', 1, 0)) %>% mutate( 'binary_region_factor' = ifelse(region == 'Inner London', "Inner London", "Outside London"))


fd[,'marstat'] <- factor(fd[,'marstat'], level = c(1,2,3,4,5,6), 
                           labels = c('Single', 'Married', 'Same-sex', 'Separated', 
                                      'Divorced', 'Widowed'))

fd <- mutate(fd, 'binary_marstat' = ifelse(marstat == "Separated" | marstat == 'Divorced', 1, 0))

fd[,'transport']<- factor(fd[,'transport'], levels = c(1, 2, 3, 4, 5, 6, 7,
                                                           8, 9, 10, 11), 
                            labels = c('Work from home', 'metro', 'Train', 'Bus',
                                       'Taxi', 'Motocycle', 'drive a car', 'passenger in a car', 
                                       'Bicycle', 'On foot', 'Other'))

fd[,'wpzhome'] <- factor(fd[,'wpzhome'], level = c(1,2,3,4,5), 
                           labels = c('Work from home', 'Same zone', 'Outside zone, but same LA/UA district',
                                      'Outside LA/UA/LGD', 'Workplace outside UK'))

fd[,'aggdtwpew11g'] <- factor(fd[,'aggdtwpew11g'], level = c(1, 2, 3, 4, 5, 6, 7,
                                                                 8, 9, 10, 11, 12), 
                                labels = c('less than 2km', '2-5', '5-10', '10-20', 
                                           '20-40', '40-60', '60 or more', 'at home', 
                                           'No fixed place', 'Outside England and Wales but in UK', 
                                           'Outside UK', 'Offshore but within UK'))

fd <- mutate(fd, Highest_qualification = hlqupuk11)
fd[,'Highest_qualification'] <- factor(fd[,'Highest_qualification'], 
                                            levels = c(10, 11, 12, 13, 14, 15, 16), labels = c('No qualification', 'Level 1', 'Level 2', 'Apprenticeship','Level 3', 'Level 4', 'Others'))

fd[,'hours']<- factor(fd[,'hours'], level= c(1,2,3,4), labels = c('15 or less', '16-30', '31-48','49 or more'))

fd[, 'tenure'] <- factor(fd[,'tenure'], levels = c(1, 2, 3, 4, 5), 
                           labels = c('Owns outright', 'Owns with a mortgage', 'Shared ownership', 'Rents', 'Rent-free'))

fd <- fd%>% mutate(no_of_children = dpcfamuk11)%>% mutate(children_class = ifelse(dpcfamuk11==1, 'No children', ifelse(dpcfamuk11==2|dpcfamuk11==3|dpcfamuk11==4|dpcfamuk11==5|dpcfamuk11==6|dpcfamuk11==7, 'One child', ifelse(dpcfamuk11==8|dpcfamuk11==9|dpcfamuk11==10|dpcfamuk11==11|dpcfamuk11==12|dpcfamuk11==13, 'Two children', ifelse(dpcfamuk11==14|dpcfamuk11==15|dpcfamuk11==16|dpcfamuk11==17|dpcfamuk11==18|dpcfamuk11==19, 'Three or more children', NA)))))

fd <- fd %>% mutate(youngest_child_age = ifelse(dpcfamuk11==1, 'No children', ifelse(dpcfamuk11==2|dpcfamuk11==8|dpcfamuk11==14, 'youngest aged 0-4', ifelse(dpcfamuk11==3|dpcfamuk11==9|dpcfamuk11==15, 'youngest aged 5-7', ifelse(dpcfamuk11==4|dpcfamuk11==10|dpcfamuk11==16, 'youngest aged 8-9', ifelse(dpcfamuk11==5|dpcfamuk11==11|dpcfamuk11==17, 'youngest aged 10-11', ifelse(dpcfamuk11==6|dpcfamuk11==12|dpcfamuk11==18, 'youngest aged 12-15', ifelse(dpcfamuk11==7|dpcfamuk11==13|dpcfamuk11==19, 'youngest aged 16-18', NA))))))))

```

# Descriptive Statistics and Correlation Tests
Simple descriptive statistis including bar charts, pie charts, density graph... etc. 
We can show a few correlation tests, chi-squre tests and graphs

## Social and Economic Status & Marriage 



## Culture & Marriage

It cannot be denied that the cultural package each person has, is a major factor in his conception of marriage, his expectations toward a relationship and his values about divorce. Thus, in this part, we examine the factors of Ethnicity, Religion and Country of birth to try to determine the effect it has on divorce rate. 

These variables are distributed as the following pie charts show :

```{r, echo=FALSE, message = FALSE}
# Importing Data
#url <- "https://raw.githubusercontent.com/dlouhasha/TheGreatWork/master/data/filtered_dataset.csv"

setwd(dir= "/Users/christelleren/Desktop/Imperial/Pre-term/R - Maths and Statistics Fundations/Projet1")
filtered_data <- read.csv(file="filtered data.csv", header=TRUE, sep=",")

#filtered_data <- getURL(url)
#filtered_data <- read.csv(textConnection(filtered_data))
myowndata <- filtered_data[,c('marstat', 'binary_marstat', 'cobg', 'ethnicityew', 'religionew')]

```

```{r, echo = FALSE}
# Factoring Data

myowndata[, 'cobg'] <- factor(myowndata[, 'cobg'], levels = seq(1,26), labels = c("England","Scotland", "Northern Ireland", "Wales", "United Kingdom not otherwise specified", "Ireland", "Germany", "Poland", "Other EU countries: Member countries in 2001", "Other EU countries: Accession countries 2001 to 2011", "Rest of Europe", "North Africa", "Central and Western Africa", "South and Eastern Africa", "Africa not otherwise specified", "Middle East", "Eastern Asia", "Southern Asia: Bangladesh", "Southern Asia: India", "Southern Asia: Pakistan", "Rest of Southern Asia", "South-East Asia", "Central Asia", "North America and the Caribbean", "Central and South America", "Antarctica, Oceania and other"))

myowndata[, 'binary_marstat'] <- factor(myowndata[, 'binary_marstat'], levels = c(1,0), labels = c("Separated/Divorced","Married/In a relationship"))

myowndata[, 'ethnicityew'] <- factor(myowndata[, 'ethnicityew'], levels = seq(1,18), labels = c("English/Welsh/Scottish/Northern Irish/British", "Irish", "Gypsy or Irish Traveller", "Other White", "Mixed/multiple ethnic group: White and Black Caribbean", "Mixed/multiple ethnic group: White and Black African", "Mixed/multiple ethnic group: White and Asian", "Mixed/multiple ethnic group: Other Mixed", "Indian", "Pakistani", "Bangladeshi", "Chinese", "Other Asian", "African", "Caribbean", "Other Black", "Arab", "Any other ethnic group"))

myowndata[, 'religionew'] <- factor(myowndata[, 'religionew'], levels = seq(1,9), labels = c("No religion", "Christian", "Buddhist", "Hindu", "Jewish", "Muslim", "Sikh", "Other religion", "Not stated"))

myowndata <- na.omit(myowndata)

myowndata$ethngrouped <- ifelse(myowndata$ethnicityew == "English/Welsh/Scottish/Northern Irish/British"  | myowndata$ethnicityew == "Irish" | myowndata$ethnicityew == "Gypsy or Irish Traveller"| myowndata$ethnicityew == "Other White", "White", 
                                ifelse( myowndata$ethnicityew == "Indian" | myowndata$ethnicityew == "Pakistani"| myowndata$ethnicityew == "Bangladeshi" | myowndata$ethnicityew == "Chinese"| myowndata$ethnicityew == "Other Asian", "Asian", 
                                        ifelse(myowndata$ethnicityew == "African" | myowndata$ethnicityew == "Caribbean"| myowndata$ethnicityew == "Other Black", "Black", 
                                               ifelse(myowndata$ethnicityew == "Arab", 'Arab', 
                                                      ifelse(myowndata$ethnicityew == "Any other ethnic group", "Any other", "Mix Group")))))

```

```{r, echo = FALSE, message=FALSE}

mydata_ethn <- myowndata %>% group_by(ethngrouped) %>% summarise(count = n()) 

lbls <- paste(mydata_ethn$ethngrouped, mydata_ethn$count) 
lbls <- paste(lbls,"%",sep="") 
pie(mydata_ethn$count, labels = mydata_ethn$ethngrouped, col=rainbow(length(lbls)), main="Pie chart of ethnicities")

mydata_relig <- myowndata %>% group_by(religionew) %>% summarise(count = n()) 

lbls2 <- paste(mydata_relig$religionew, mydata_relig$count) 
lbls2 <- paste(lbls,"%",sep="") 
pie(mydata_relig$count, labels = mydata_relig$religionew, col=rainbow(length(lbls2)), main="Pie chart of religions")
```


Our assumption is that divorce rate will be higher among white people who are generally considered having more liberal values, and permissive laws for divorce. We also expect that the less commited people are toward religion, the more they are likely to get divorced.


```{r, echo = FALSE}
# Correlation tests
cor.test(filtered_data$religionew, filtered_data$binary_marstat)

cor.test(filtered_data$ethnicityew, filtered_data$binary_marstat)

cor.test(filtered_data$cobg, filtered_data$binary_marstat)
```



```{r, echo = FALSE, eval=FALSE}
# Chi-Square Test

chisq.test(myowndata$cobg, myowndata$binary_marstat)

chisq.test(myowndata$ethnicityew, myowndata$binary_marstat)

chisq.test(myowndata$religionew, myowndata$binary_marstat)
```

Basic correlation tests between the marital status and the different variables (religion, ethnicities, country of birth) indicate that there is a correlation (p-value < 5%). Our aim is to have more insight about it.

### Ethnicities

```{r, echo = FALSE, message=FALSE, warning=FALSE}
ethn <- myowndata %>% dplyr::select(binary_marstat, ethnicityew) %>% group_by(binary_marstat, ethnicityew) %>% summarise(count = length(binary_marstat)) %>% ungroup() %>% group_by(ethnicityew) %>% mutate(prop = count / sum(count))


ethn_divorced = filter(ethn, binary_marstat == "Separated/Divorced")
ethn_divorced <- ethn_divorced[order(ethn_divorced$prop),]


# Grouping ethnicities

ethn$ethngrouped <- ifelse(ethn$ethnicityew == "English/Welsh/Scottish/Northern Irish/British"  | ethn$ethnicityew == "Irish" | ethn$ethnicityew == "Gypsy or Irish Traveller"| ethn$ethnicityew == "Other White", "White", 
                                ifelse( ethn$ethnicityew == "Indian" | ethn$ethnicityew == "Pakistani"| ethn$ethnicityew == "Bangladeshi" | ethn$ethnicityew == "Chinese"| ethn$ethnicityew == "Other Asian", "Asian", 
                                        ifelse(ethn$ethnicityew == "African" | ethn$ethnicityew == "Caribbean"| ethn$ethnicityew == "Other Black", "Black", 
                                               ifelse(ethn$ethnicityew == "Arab", 'Arab', 
                                                      ifelse(ethn$ethnicityew == "Any other ethnic group", "Any other ethnic group", "Mix Group")))))



```

```{r, echo = FALSE, message=FALSE, warning=FALSE}
ethngrouped <- ethn %>% dplyr::select(binary_marstat, ethngrouped, count) %>% group_by(ethngrouped, binary_marstat) %>% summarise(grouped_count = sum(count)) %>% ungroup() %>% group_by(ethngrouped) %>% mutate(prop = grouped_count/ sum(grouped_count))  

#ggplot(data=ethngrouped) + geom_bar(aes(x = binary_marstat, y = prop, fill = binary_marstat), stat = 'identity', position = position_dodge())  + theme(axis.text.x = element_text(angle = 45, hjust = 1)) + labs(title = 'ethnicity grouped') + facet_wrap(~ ethngrouped)

#ggplot(data=ethngrouped) + geom_bar(aes(x = binary_marstat, y = prop, fill = reorder(ethngrouped, prop)), stat = 'identity', position = position_dodge())  + theme(axis.text.x = element_text(angle = 45, hjust = 1)) + labs(title = 'ethnicity grouped') 

ethngrouped_divorced = filter(ethngrouped, binary_marstat == "Separated/Divorced")

ggplot(data=ethngrouped_divorced) + geom_bar(aes(x = reorder(ethngrouped, prop), y = prop, fill = ethngrouped), stat = 'identity', position = position_dodge()) + theme(axis.text.x = element_text(angle = 45, hjust = 1)) + labs(title = 'Divorce Rate per Ethnicity')

```

The divorce rate shows us some insight that we expected. For example, Asian divorce rate is significantly lower that for White people. The divorce rate is also very high for a person of mixed ethnicities. This might be explained by the fact that a mixed couple requires a more considerable amount of culture adjustment and understandings, and is more likely to divorce. Parents' value about divorce may thus transmitted to the child.
However, one more unexpected result is that divorce rate are the highest among black people. If this trends has been the subject of a lot of studies in the US (e.g. http://www.swaraylawoffice.com/2010/08/divorce-rate-amongst-african-immigrants/), they are quite scarce about UK. 
It is commonly known that Black people are still strongly discriminated against in the US, with inequalities in wages, access to education and higher crime rate. But these do not explain entirely the high divorce rate among Black people in UK as we can see in the Education/Ethnicity cross checking, divorce rate is high among Black people no matter whar their education level is. 
An other reason we can think about is the discrepancy between African and European culture. Women in Africa are inferior to men, and confine themselves to domestic role. In UK, the women have the same rights as men, both socially and economically, giving them more independance and possibly leading to frictions.



## Country of birth

```{r, echo = FALSE, message=FALSE, warning=FALSE}
cb <- myowndata %>% dplyr::select(binary_marstat, cobg) %>% group_by(binary_marstat, cobg) %>% summarise(count = length(binary_marstat)) %>% ungroup() %>% group_by(cobg) %>% mutate(prop = count / sum(count))
```

```{r, echo = FALSE, message=FALSE, warning=FALSE}

## Grouping countries of birth by area

cb$cobggrouped <- ifelse(cb$cobg == "England" | cb$cobg == "Scotland"| cb$cobg == "Northern Ireland"  | cb$cobg =="Wales"  | cb$cobg =="United Kingdom not otherwise specified" , "UK", 
                         ifelse(cb$cobg =="Ireland" | cb$cobg =="Germany"  | cb$cobg =="Poland"  | cb$cobg =="Other EU countries: Member countries in 2001"  | cb$cobg =="Other EU countries: Accession countries 2001 to 2011"  | cb$cobg =="Rest of Europe", "Europe",
                                ifelse( cb$cobg == "Middle East" | cb$cobg == "Eastern Asia" | cb$cobg == "Southern Asia: Bangladesh" | cb$cobg == "Southern Asia: India" | cb$cobg == "Southern Asia: Pakistan" | cb$cobg == "Rest of Southern Asia" | cb$cobg == "South-East Asia" | cb$cobg == "Central Asia", "Middle East and Asia", 
                                        ifelse(cb$cobg ==  "North Africa" | cb$cobg == "Central and Western Africa" | cb$cobg == "South and Eastern Africa" | cb$cobg == "Africa not otherwise specified", "Africa", 
                                               ifelse(cb$cobg == 'North America and the Caribbean' | cb$cobg == 'Central and South America', 'The Americas and the Caribbean', 'Antarctica, Oceania and other')))))

myowndata$cobggrouped <- ifelse(myowndata$cobg == "England" | myowndata$cobg == "Scotland"| myowndata$cobg == "Northern Ireland"  | myowndata$cobg =="Wales"  | myowndata$cobg =="United Kingdom not otherwise specified" , "UK", 
                         ifelse(myowndata$cobg =="Ireland" | myowndata$cobg =="Germany"  | myowndata$cobg  =="Poland"  | myowndata$cobg  =="Other EU countries: Member countries in 2001"  | myowndata$cobg  =="Other EU countries: Accession countries 2001 to 2011"  | myowndata$cobg  =="Rest of Europe", "Europe",
                                ifelse( myowndata$cobg  == "Middle East" | myowndata$cobg  == "Eastern Asia" | myowndata$cobg  == "Southern Asia: Bangladesh" | myowndata$cobg  == "Southern Asia: India" | myowndata$cobg  == "Southern Asia: Pakistan" | myowndata$cobg  == "Rest of Southern Asia" | myowndata$cobg  == "South-East Asia" | myowndata$cobg  == "Central Asia", "Middle East and Asia", 
                                        ifelse(myowndata$cobg  ==  "North Africa" | myowndata$cobg  == "Central and Western Africa" | myowndata$cobg  == "South and Eastern Africa" | myowndata$cobg  == "Africa not otherwise specified", "Africa", 
                                               ifelse(myowndata$cobg  == 'North America and the Caribbean' | myowndata$cobg  == 'Central and South America', 'The Americas and the Caribbean', 'Antarctica, Oceania (including Australasia) and other')))))

```

```{r, echo = FALSE, message=FALSE, warning=FALSE}
cbgrouped <- cb %>% dplyr::select(binary_marstat, cobggrouped, count) %>% group_by(cobggrouped, binary_marstat) %>% summarise(grouped_count = sum(count)) %>% ungroup() %>% group_by(cobggrouped) %>% mutate(prop = grouped_count/ sum(grouped_count))  

#ggplot(data = cbgrouped) + geom_bar(aes(x = binary_marstat, y = prop, fill = binary_marstat), stat = 'identity', position = position_dodge())  + theme(axis.text.x = element_text(angle = 45, hjust = 1)) + labs(title = 'countries of birth grouped') + facet_wrap(~ cobggrouped)

cbgrouped_divorced = filter(cbgrouped, binary_marstat == "Separated/Divorced")

ggplot(data=cbgrouped_divorced) + geom_bar(aes(x = reorder(cobggrouped, prop), y = prop, fill = cobggrouped), stat = 'identity', position = position_dodge()) + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + labs(title = 'Country of Birth')
```

The countries of birth tend to confirm the pattern we already found for ethnicities. 
We can see that the trend of the countries of birth has some similarities with the world divorce ration heatmap you can find following this link: http://i.imgur.com/dep7XIZ.png.


```{r, echo = FALSE}
#myowndata %>% select(binary_marstat, cobggrouped, ethngrouped) %>% group_by(cobggrouped, ethngrouped) %>% summarise(count = n())%>% tidyr::spread(key = ethngrouped, value = count)
```
 
 

## Religion
```{r, echo = FALSE}
relig <- myowndata %>% dplyr::select(binary_marstat, religionew) %>% group_by(binary_marstat, religionew) %>% summarise(count = length(binary_marstat)) %>% ungroup() %>% group_by(religionew) %>% mutate(prop = count / sum(count))

#ggplot(data=relig) + geom_bar(aes(x = binary_marstat, y = prop, fill = binary_marstat), stat = 'identity', position = position_dodge()) + facet_wrap(~ religionew) + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + labs(title = 'religion')

relig_divorced = filter(relig, binary_marstat == "Separated/Divorced")

ggplot(data=relig_divorced) + geom_bar(aes(x = reorder(religionew, prop), y = prop, fill = religionew), stat = 'identity', position = position_dodge()) + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + labs(title = 'Religion')
```

```{r, echo = FALSE}
myowndata %>% select(binary_marstat, religionew, ethngrouped) %>% group_by(religionew, ethngrouped) %>% summarise(count = n()) %>% tidyr::spread(key = ethngrouped, value = count)
```
Cross-checking the religion and ethnicities variables, we can observe that the religions with the highest divorce rate are 'Other religion', 'No religion' or 'No stated', which might be a sign of more liberal values.
Buddhists also have high divorce rate, probably due to its permissive point of view toward divorce (https://www.budsas.org/ebud/whatbudbeliev/237.htm). However, the ratio of Buddhists is very low, so their divorce rate has to be taken carefully.
Finally, the next religion with the highest divorce rate is Christianism which is not so surprising. Unlike in Catholic Church where marriage is a sacred union, the Church of England has a more open point of view on divorce (which can be related to the historical divorce of Henri VIII). Not to mention that Europeans tend to be less and less committed and involved in religions.


## Age & Marriage
Contains information about the age of the observation (person) in years. This variable ranges from 0 to 90 and is treated as a continuous variable. Ages 70, 75, 80, and 85 are clustered into groups each ranging 5 years (i.e. 70 through 74, 75 through 79, etc...). Furthermore, the 90 age group conatins ages 90 and above.

For the purposes of this analysis, and to calculate the divorce rate by age, the clustered age groups were equally distibuted among the number of ages the group contains. (e.g the 70 through 74 age group was divided into 5 seperate age groups 70, 71, 72, 73, and 74 each inherenting the parent group's divorce rate).

Exhibit 1: Density of un-modified age


The chart below, depicts the density distribution of ages in the dataset before any modifications were applied. As expected, instances of the observations' ages are relatively equal among the dataset, which should ensure a fair representation of all age groups.
```{r}
#need to add in original dataset to show density of original age distribution
ggplot(data = fd, aes(x = age)) + geom_density()
```
Exhibit 2: Divorce rate by age:

The chart above shows the divorce rate (as defined in the introduction) for each of the 83 age groups (18 to 100). 
The divorce rate for observations aged 18, 19, and 20 is significantly higher than observations in their 20's. The rationale for this observation is the scarcity (nominally) of married people who are 20 and less, which results in a large relative proportion of divorced people when compared to other age groups.
The age with the highest divorce rate in the dataset is 48. This is likely due to the fact that younger people are less likely to be divorced, as those would be early-on in their marriages. Furthermore, older people have a greater chance of being deceased and of being remarried.

```{r}

data2 <-  fd %>% filter(marstat == 2 | marstat == 3 | marstat == 4 | marstat == 5) %>% filter(age >= 18) %>% mutate(seperated = marstat) %>% mutate(seperated = replace(seperated, marstat!= 5 | marstat != 4, 0)) %>% mutate(seperated = replace(seperated, marstat == 5 | marstat == 4, 1))
#new dataframe containing the summarised count by age
total_group <- data2 %>% dplyr::select(age, seperated) %>% group_by(age) %>% summarise(count = n())
total_group_full <- total_group[1:52,]
dummy1 <- data.frame(age = 70:100)
dummy1$count <- rep(1,31)
dummy1$count[1:5] <- rep(round(total_group$count[53] / 5), 5)
dummy1$count[6:10] <- rep(round(total_group$count[54] / 5), 5)
dummy1$count[11:15] <- rep(round(total_group$count[55] / 5), 5)
dummy1$count[16:20] <- rep(round(total_group$count[56] / 5), 5)
dummy1$count[21:31] <- rep(round(total_group$count[57] / 11), 11)
new_total_group <- rbind.data.frame(total_group_full, dummy1)

#create a new sub-data frame from data2 grouped by age and seperated status and summarised 
divorced <-  data2 %>% dplyr::select(age, seperated) %>% filter(seperated == 1) %>% group_by(age, seperated) %>% summarise(n = n()) %>% ungroup() %>% group_by(seperated) %>% mutate(prop = n / sum(n) * 100)

#new divorced_full dataframe that contains all age groups above 70 i.e (70 to 100) since the orignal dataset groups ges above 70 by increments of 5. Count of divorced people was divided equally among the five tranches
divorced_full <- divorced[1:52,]
dummy <- data.frame(age = 70:100)
dummy$seperated <- rep(1,31)
dummy$n <- rep(1,31)
dummy$prop <- rep(1,31)
dummy$n[1:5] <- rep(divorced$n[53] / 5, 5)
dummy$prop[1:5] <- rep(divorced$prop[53] / 5, 5)
dummy$n[6:10] <- rep(divorced$n[54] / 5, 5)
dummy$prop[6:10] <- rep(divorced$prop[54] / 5, 5)
dummy$n[11:15] <- rep(divorced$n[55] / 5, 5)
dummy$prop[11:15] <- rep(divorced$prop[55] / 5, 5)
dummy$n[16:20] <- rep(divorced$n[56] / 5, 5)
dummy$prop[16:20] <- rep(divorced$prop[56] / 5, 5)
dummy$n[21:31] <- rep(divorced$n[57] / 11, 11)
dummy$prop[21:31] <- rep(divorced$prop[57] / 11, 11)
new_divorced <- rbind.data.frame(divorced_full, dummy)

#create new data.frame to calculate the divorce rate per age. This is done by dividing the count of divorced people from divorced data frame by the respective rows from the total group data frame 
divorce_by_age <- data.frame(prop = c(1:83), age = new_divorced$age)
divorce_by_age$prop <- rep(1, 83)
divorce_by_age$prop <- new_divorced$n / new_total_group$count * 100

ggplot(data = divorce_by_age, aes(x = age, y = prop)) + geom_line()
```

Exhibit 3: Density of modified age

The chart below depicts the density distribution of ages in the modified dataset, wherein the single people in the dataset were excluded as these were irrelevant for our purposes. Furthermor, age groups below 22 were excluded as those were deemed to be outliers, and age groups of 70 and above were excluded as those were manually manipulated to give significance. This shows, as expected a much smoother curve, with characteristics of a bell curve (normal distribution).
```{r}
data3 <-  fd %>% filter(age > 22 & age < 70)
ggplot(data = data3, aes(x = age)) + geom_density()
```

Exhibit 4: Divorce rate by age:

The chart above shows the divorce rate (as defined in the introduction) for each of the 83 age groups (18 to 100). The divorce rate for observations aged 18, 19, and 20 is significantly higher than observations in their 20's. The rationale for this observation is the scarcity (in nominal terms) of married people who are 20 and less, which results in a large relative proportion of divorced people when compared to other age groups.
```{r}
#create new data.frame to calculate the divorce rate per age. This is done by dividing the count of divorced people from divorced data frame by the respective rows from the total group data frame 
divorce_by_age <- data.frame(prop = c(1:83), age = new_divorced$age)
divorce_by_age$prop <- rep(1, 83)
divorce_by_age$prop <- new_divorced$n / new_total_group$count * 100

ggplot(data = divorce_by_age, aes(x = age, y = prop)) + geom_line()
```
Exhibit 5: proportion of divorced people by age

The chart above shows the proportion of divorced people for each age group. The chart shows a curve resembling a normal distribution.
```{r}
ggplot(data = new_divorced, aes(x = age, y = prop)) + geom_line()
```
Exhibit 5: Divorce rate by age and sex

The chart below is an exhibit of divorce rates by age for each sex. The general trend presented is a consistintly higher divorce rate for women across all age groups. This seems to suggest that women are more likely to be divorced than men on average.
A t test of mean divorce rate between men and women reveals a statistically significant difference between the mean divorce rate of men and women.

```{r}
data3 <-  data2 %>% filter(age > 22 & age < 70)
total_group1 <- data3 %>% dplyr::select(age, seperated, sex) %>% group_by(age, sex) %>% summarise(count = n())
divorce_by_age_bysex <- data.frame(age = total_group1$age)
divorce_by_age_bysex$prop <- divorced_bysex$n / total_group1$count * 100
divorce_by_age_bysex$sex <- divorced_bysex$sex
divorce_by_age_bysex$sex <- factor(divorce_by_age_bysex$sex, levels = c(1,2), labels = c('Male', 'Female'))
ggplot(data = divorce_by_age_bysex, aes(x = age, y = prop, fill = sex)) + geom_col(position = 'dodge') + ylab("%")

male <- divorce_by_age_bysex %>% filter(sex == 'Male')
female <- divorce_by_age_bysex %>% filter(sex == 'Female')
t.test(male$prop, female$prop)


```



## Region/Geography & Marriage
An article on divorce rate by region piqued our interests (http://www.dailymail.co.uk/news/article-3201497/Wish-weren-t-ten-divorce-hot-spots-Britain-sea-Blackpool-worst-place-live-want-happy-marriage.html). It lists the top 10 divorce hot spots and they are all coastal cities. The article states that the factors contributing to the high divorce rate in coastal regions are due to the high deprivation and possibly sheer boredoem in winter. In this paper we are keen to explore whether our data attests to the findings of that article. 

Our data shows a significant peak in inner London which shows that the percentage of people in bad marriage (either divorced or separated) is much higher than elsewhere. This is the opposite to the aforementioned article. London is anything but a deprived and boring city. We would like to conduct a hypothesis testing to see (1) if region and marital status are independent, (2) if London has the highest divorce rate and (3) if so what the influencing factors are. The test we adopt here is chi-squared test to explore the correlations between region and marital status and t-test for testing of difference in divorce rates across regions. 


The p-values are both less than 5% and it means that the we can reject the null hypothesis that region and marital status are independent. From the residuals of chi-squared test, we see that married couples are greatly underrepresented in Inner London, but divorced and separated couples are over represented. 

```{r, echo = FALSE}
# select the data relevant for region
region1 <- dplyr:: select(fd, binary_marstat, age, aggdtwpew11g, region, marstat, transport, wpzhome, Highest_qualification, binary_region_factor, binary_region_num,hours, tenure)

region_count<- region1 %>% select(marstat, region) %>% group_by(region, marstat)%>% summarise(count = n())%>% tidyr::spread(key = marstat, value = count) %>% mutate(divorce_rate = (Divorced + Separated)/(Divorced + Married + Separated))

```

```{r region_plot, fig.width=3,fig.height=3}
# plot divorce rate for region
region1%>% group_by(region) %>% summarise(divorce_rate = mean(binary_marstat))%>% ggplot(aes(x = region, y = divorce_rate))+ geom_col() + theme(axis.text.x = element_text(angle = 30, hjust = 1))
```

```{r}
# chi-squared test
region_test <- region_count[,-1]
rownames(region_test) <- as.data.frame(region_count)[,1]
chi_region <- chisq.test(as.data.frame(region_test))
chi_region

```

Chi-squared test residuals on regional marital status analysis
```{r}
round(chi_region$residuals, 3)['Inner London',]
```

We further perform t-test to compare the divorce rate of Inner London and all the other regions. Inner London has a divorce rate of approximately 25%, higher than the average of 20% across all regions. The difference is statistically significant. 

```{r region_ttest, echo = FALSE}
t.test(fd$binary_marstat, fd$binary_marstat[fd$region == "Inner London"])
```

```{r, echo = FALSE, eval = FALSE}
#mean_London <- fdata$binary_marstat[fdata$region == "Inner London"]
outside_london <- fd$binary_marstat[fd$region != "Inner London"]

t.test(outside_london, fd$binary_marstat[fd$region == "North East"])
t.test(outside_london, fd$binary_marstat[fd$region == "North West"])
t.test(outside_london, fd$binary_marstat[fd$region == "Yorkshire and the Humber"])
t.test(outside_london, fd$binary_marstat[fd$region == "East Midlands"])
t.test(outside_london, fd$binary_marstat[fd$region == "West Midlands"])
t.test(outside_london, fd$binary_marstat[fd$region == "East of England"])
t.test(outside_london, fd$binary_marstat[fd$region == "Outer London"])
t.test(outside_london, fd$binary_marstat[fd$region == "South East"])
t.test(outside_london, fd$binary_marstat[fd$region == "South West"])
t.test(outside_london, fd$binary_marstat[fd$region == "Wales"])

```

Could the place people choose to live affect their marriage satisfaction, or is it merely an artifact as a result of distributions of other influencing factors? We plot the divorce rates against other variables in our list and wrap them by region. If the variables have no impact, we should observe the same pattern across all regions, with London having a slightly higher divorce rate. 

Findings: we observe a significantly high divorce rate for people aged 50 and above in Inner London, while inner London is a very young city with mean age of residents at around 47, and median age 45 (population mean and median are both 52). To explore it further we break down the population into two groups: age below 50 and age 50 and above. In the first group we no longer see any significant difference in divorce rates across regions, but the difference becomes more apparent in the second group. The observation suggests a larger proportion of people aged 50 and above are divorced or separated in Inner London than elsewhere. 

According to Office for National Statistics in their online publication in July 2017, while the number of divorces drop by 28% from 2005 to 2015, the number of men divorcing aged above 65 went up by 23% and 38% for women.  (https://visual.ons.gov.uk/marriage-and-divorce-on-the-rise-at-65-and-over/). 

Various factors contribute to the increasing divorce rate among older people (Susan L. Brown and I-Fen Lin 18 Oct 2012, https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3478728/). A better economic security, and more social interactions with people are among them. More significanty observed in their data is that people in higher order marriages are more likely to end up in divorces than people in first marriage (53.46% compared to 46.54%). And people in their 50s and 60s are also more likely to be in higher order marriages compared to younger people. 

However we must be careful not to confuse the status of being divorced or separated with the instance of getting a divorce. In our data we look at the percentage of people who are divorced or separated at the time of the survey, without information on when and where the divorce occured. It could also be possible that people in inner London are less likely to remarry after they are divorced, just like London has the highest percentage of singles aged 30 and above. London is fun and people could be just having a good time being single or in relationships, without rushing into any marriage. Above all, London is the number one Tinder hotspots. 


```{r region_vs_others, echo = FALSE, eval= FALSE}
# divorce rate by variables and wrapped by region

#divorce rate by age 
fd %>% group_by(region, age) %>% summarise(divorce_rate = mean(binary_marstat))%>% ggplot(aes(x = age, y = divorce_rate))+ geom_col() + facet_wrap(~region)

#divorce rate by children_class
fd %>% filter(!is.na(children_class))%>% group_by(region, children_class) %>% summarise(divorce_rate = mean(binary_marstat))%>% ggplot(aes(x = children_class, y = divorce_rate))+ geom_col() + facet_wrap(~region)+ theme(axis.text.x = element_text(angle = 60, hjust = 1))  

#divorce rate by Highest_qualification
fd %>% filter(!is.na(Highest_qualification) & Highest_qualification != 'Others') %>%group_by(region, Highest_qualification) %>% summarise(divorce_rate = mean(binary_marstat))%>% ggplot(aes(x = Highest_qualification, y = divorce_rate))+ geom_col() + facet_wrap(~region)+ theme(axis.text.x = element_text(angle = 60, hjust = 1)) 

#divorce rate by hours worked
fd %>% filter(!is.na(hours)) %>%group_by(region, hours) %>% summarise(divorce_rate = mean(binary_marstat))%>% ggplot(aes(x = hours, y = divorce_rate))+ geom_col() + facet_wrap(~region)+ theme(axis.text.x = element_text(angle = 60, hjust = 1))  

#divorce rate by ethnicity
fd %>% filter(!is.na(ethnicityew)) %>%group_by(region, ethnicityew) %>% summarise(divorce_rate = mean(binary_marstat))%>% ggplot(aes(x = ethnicityew, y = divorce_rate))+ geom_col() + facet_wrap(~region)+ theme(axis.text.x = element_text(angle = 60, hjust = 1))  

#divorce rate by religion
fd %>% filter(!is.na(religionew)) %>%group_by(region, religionew) %>% summarise(divorce_rate = mean(binary_marstat))%>% ggplot(aes(x = religionew, y = divorce_rate))+ geom_col() + facet_wrap(~region)+ theme(axis.text.x = element_text(angle = 60, hjust = 1))  

#divorce rate by tenure
fd %>% filter(!is.na(tenure)) %>%group_by(region, tenure) %>% summarise(divorce_rate = mean(binary_marstat))%>% ggplot(aes(x = tenure, y = divorce_rate))+ geom_col() + facet_wrap(~region)+ theme(axis.text.x = element_text(angle = 60, hjust = 1))  

#divorce rate by distance to work
fd %>% filter(!is.na(wpzhome)) %>%group_by(region, wpzhome) %>% summarise(divorce_rate = mean(binary_marstat))%>% ggplot(aes(x = wpzhome, y = divorce_rate))+ geom_col() + facet_wrap(~region)+ theme(axis.text.x = element_text(angle = 60, hjust = 1))  

```

```{r region_vs_age}
# divorce rate by age and wrapped by regions
fd %>% group_by(region, age) %>% summarise(divorce_rate = mean(binary_marstat))%>% ggplot(aes(x = age, y = divorce_rate))+ geom_col() + facet_wrap(~region)
```

```{r, echo = FALSE, eval = FALSE}
#distribution of age wrapped by region
fd %>% filter(!is.na(age))%>% ggplot(aes(x = age))+ geom_histogram() + facet_wrap(~region)

#divorce rate by region for aged below 50
region1%>% filter(age <50) %>% group_by(region) %>% summarise(divorce_rate = mean(binary_marstat))%>% ggplot(aes(x = region, y = divorce_rate))+ geom_col() + theme(axis.text.x = element_text(angle = 30, hjust = 1))

#divorce rate by region for aged 50 and above
region1%>% filter(age >=50) %>% group_by(region) %>% summarise(divorce_rate = mean(binary_marstat))%>% ggplot(aes(x = region, y = divorce_rate))+ geom_col() + theme(axis.text.x = element_text(angle = 30, hjust = 1))
```

### Dependent children

When people get married they are often in love and happy, most married couples look forward parenthood and having children could even strengthen their marital bond. However empirical study shows that the effect of children on marital stability could be very complex. Children increase the stability of marriage only when they are preschool-aged (Becker et al. 1977), as they grow older, their binding force in a marriage weakens; the greater number of children, the smaller possibility of divorce, but the relationship is inversely quadratic rather than linear suggesting the stabilizing effect is the strongest with the first and second child (Xu, Yu and Qiu 2015). 

The birth of an infant often brings couples back together who would have otherwise divorced. Experiencing divorce often place young children at risk for a variety of problems, which may persist into adulthood (Morrisox and Coiro, 1999). Married couples may choose to stay in marriges for the wellbeing of their children but when children are old enough they decide to part their ways. 

We are keen to explore if we observe the same pattern in our data (1) as the age of youngest child grows, the more likely the couple will get divorced/separated (2) the more children a couple have, the less likely they are to be divorced/separated. 


Becker, Gary S., Elizabeth Landes, and Robert T. Michael. 1977. "An Economic Analysis of Marital Instability." Journal of Political Economy 85:1141-87.

Waite, Linda J, and Lee A Lillard. 1991. Children and marital disruption. American Journal of Sociology 96(4):930–953. 

Qi Xu1*, Jianning Yu2 and Zeqi Qiu3. 2015, The impact of children on divorce risk. Xu et al. The Journal of Chinese Sociology (2015) 2:1

Donna Ruane Morrisox and Mary Jo Coiro, Parental Conflict and Marital Disruption: Do Children Benefit When High-Conflict Marriages Are Dissolved?. Journal of Marriage and the Family 6 1 (August 1999): 626-637


```{r}
family_compo <- fd%>% select(youngest_child_age, dpcfamuk11, tenure, binary_marstat, binary_region_factor, scgpuk11c, children_class) 

%>% mutate(no_of_children = dpcfamuk11)%>% mutate(children_class = ifelse(dpcfamuk11==1, 'No children', ifelse(dpcfamuk11==2|dpcfamuk11==3|dpcfamuk11==4|dpcfamuk11==5|dpcfamuk11==6|dpcfamuk11==7, 'One child', ifelse(dpcfamuk11==8|dpcfamuk11==9|dpcfamuk11==10|dpcfamuk11==11|dpcfamuk11==12|dpcfamuk11==13, 'Two children', ifelse(dpcfamuk11==14|dpcfamuk11==15|dpcfamuk11==16|dpcfamuk11==17|dpcfamuk11==18|dpcfamuk11==19, 'Three or more children', NA)))))


family_compo %>% select(binary_marstat, tenure, binary_region_factor, children_class, dpcfamuk11) %>% filter(!is.na(children_class))%>% group_by(children_class)%>% summarise(divorce_rate = mean(binary_marstat))%>%ggplot(aes(x = children_class, y = divorce_rate))+ geom_col() + theme(axis.text.x = element_text(angle = 60, hjust = 1))  

family_compo %>%filter(dpcfamuk11 != -9)%>% select(binary_marstat, tenure, binary_region_factor, children_class, dpcfamuk11) %>% filter(!is.na(dpcfamuk11))%>% group_by(children_class, dpcfamuk11)%>% summarise(divorce_rate = mean(binary_marstat))%>%ggplot(aes(x = dpcfamuk11, y = divorce_rate, fill = children_class))+ geom_col() + theme(axis.text.x = element_text(angle = 60, hjust = 1))  



family_compo <- fd%>% select(dpcfamuk11, tenure, scgpuk11c, binary_marstat, binary_region_factor) %>% mutate(no_of_children = dpcfamuk11)%>% mutate(children_class = ifelse(dpcfamuk11==1, 'No children', ifelse(dpcfamuk11==2|dpcfamuk11==3|dpcfamuk11==4|dpcfamuk11==5|dpcfamuk11==6|dpcfamuk11==7, 'One child', ifelse(dpcfamuk11==8|dpcfamuk11==9|dpcfamuk11==10|dpcfamuk11==11|dpcfamuk11==12|dpcfamuk11==13, 'Two children', ifelse(dpcfamuk11==14|dpcfamuk11==15|dpcfamuk11==16|dpcfamuk11==17|dpcfamuk11==18|dpcfamuk11==19, 'Three or more children', NA)))))

family_compo %>% select(dpcfamuk11, binary_marstat, tenure, scgpuk11c, binary_region_factor, children_class) %>% filter(scgpuk11c != -9) %>% filter(!is.na(children_class)) %>% group_by(dpcfamuk11, children_class)%>% summarise(divorce_rate = mean(binary_marstat))%>%ggplot(aes(x = dpcfamuk11, y = divorce_rate, fill = children_class))+ geom_col(position = 'dodge') + theme(axis.text.x = element_text(angle = 60, hjust = 1)) + labs(x = 'Number of children in family and the youngest child age')


```


## Dependent Children and Social Grade

```{r}
family_compo <- fd%>% select(dpcfamuk11, tenure, scgpuk11c, binary_marstat, binary_region_factor) %>% mutate(no_of_children = dpcfamuk11)%>% mutate(children_class = ifelse(dpcfamuk11==1, 'No children', ifelse(dpcfamuk11==2|dpcfamuk11==3|dpcfamuk11==4|dpcfamuk11==5|dpcfamuk11==6|dpcfamuk11==7, 'One child', ifelse(dpcfamuk11==8|dpcfamuk11==9|dpcfamuk11==10|dpcfamuk11==11|dpcfamuk11==12|dpcfamuk11==13, 'Two children', ifelse(dpcfamuk11==14|dpcfamuk11==15|dpcfamuk11==16|dpcfamuk11==17|dpcfamuk11==18|dpcfamuk11==19, 'Three or more children', NA)))))

family_compo %>% select(binary_marstat, tenure, scgpuk11c, binary_region_factor, children_class) %>% filter(scgpuk11c != -9) %>% filter(!is.na(children_class)) %>% group_by(scgpuk11c, children_class)%>% summarise(divorce_rate = mean(binary_marstat))%>%ggplot(aes(x = scgpuk11c, y = divorce_rate, fill = children_class))+ geom_col(position = 'dodge') + theme(axis.text.x = element_text(angle = 60, hjust = 1)) + labs(x = 'Social Class')
```


## Dependent Children and Social Grade

```{r}
family_compo <- fd%>% select(dpcfamuk11, tenure, scgpuk11c, binary_marstat, binary_region_factor) %>% mutate(no_of_children = dpcfamuk11)%>% mutate(children_class = ifelse(dpcfamuk11==1, 'No children', ifelse(dpcfamuk11==2|dpcfamuk11==3|dpcfamuk11==4|dpcfamuk11==5|dpcfamuk11==6|dpcfamuk11==7, 'One child', ifelse(dpcfamuk11==8|dpcfamuk11==9|dpcfamuk11==10|dpcfamuk11==11|dpcfamuk11==12|dpcfamuk11==13, 'Two children', ifelse(dpcfamuk11==14|dpcfamuk11==15|dpcfamuk11==16|dpcfamuk11==17|dpcfamuk11==18|dpcfamuk11==19, 'Three or more children', NA)))))

family_compo %>% select(binary_marstat, tenure, scgpuk11c, binary_region_factor, children_class) %>% filter(scgpuk11c != -9) %>% filter(!is.na(children_class)) %>% group_by(scgpuk11c, children_class)%>% summarise(divorce_rate = mean(binary_marstat))%>%ggplot(aes(x = scgpuk11c, y = divorce_rate, fill = children_class))+ geom_col(position = 'dodge') + theme(axis.text.x = element_text(angle = 60, hjust = 1)) + labs(x = 'Social Class')
```






## Health & Marriage

```{r message = FALSE, warning = FALSE, echo = FALSE}
mine <- select(fd, disability, marstat, binary_marstat)

mine$disability <- factor(mine$disability, levels = c(1,2,3), labels = c("Limit a lot", "Limit a little", "Not limited") )
mine$binary_marstat <- factor(mine$binary_marstat, levels = c(0,1), labels = c("married", "divorced"))
mine2 <- select(fd, disability, marstat, binary_marstat, scgpuk11c)
mine2 <- mine2[mine2$scgpuk11c != -9,]
mine2$disability <- factor(mine2$disability, levels = c(1,2,3), labels = c("Limit a lot", "Limit a little", "not limited") )
mine2 <- mine2 %>% group_by(disability,scgpuk11c) %>% mutate(divorce_rate = mean(binary_marstat))
mine2 <- mine2[complete.cases(mine2),]

mine3 <- mine2 %>% group_by(disability) %>% summarise(divorce_rate = mean(binary_marstat))
```

Since health is a critical factor for a satisfied life, we would like to exmaine how health may influence the marital status in the sample. There are three levels of health indicators in this dataset: "Limit a lot", "Limit a little", and "Not limited". Each level represents the degree of daily activities a person is limited to because of his or her long-term illness. The "Not limited" category indicates that a person's day to day activities are not limited at all by the long-term health illness or there is no illness. The percentage of the people falls under the category is 8.5%, 9.4%, and 82.1% for "Limit a Lot", "Limit a little", and "Not limited" respectively, according to Exhibit 1. 

```{r message = FALSE, warning = FALSE, echo = FALSE}
ggplot(mine2, aes(x= "", fill = disability))+geom_histogram(stat = "count")+coord_polar(theta = "y")
```
Exhibit 1 Pie chart of the health variable

```{r echo = FALSE}
chisq.test(mine$binary_marstat,mine$disability)
```

We first examined whether the health and marital status are independent of each other. The chi-square test indicates that there is a relationship between the two variables. To further explore how strong the relationship is, we plot the relationship. 

```{r echo = FALSE}

ggplot(mine3, aes(disability, divorce_rate))+geom_bar(stat = "identity")+labs(x = "Health", y = "Divorce Rate")
```
Exhibit 2 Health and Divorce Rate

Exhibit 2 illustrates how health has an observable impact on divorce rate. The divorce rate for "Not limited" people is 19.53%, which is 16.77% lower than the divorce rate of 36.30% for "Limit a lot" people. However, there is a chance that this model is highly correlated with other variables such as social status and may not be the real drive for this observable impact. It is possible that the people with lower social status is not able to afford healthcare or healthy lifestyle and therefore lead to higher divorce rate.


```{r echo = FALSE}
ggplot(mine2, aes(factor(scgpuk11c), divorce_rate, fill = disability))+geom_bar(stat = "identity", position = "dodge") + labs(x = "Social Grade", y = "Divorce Rate")
```
Exhibit 3 Controling the Social Grade

To validate our finding, we further examined the colinearity between social grade and health. According to Exhibit 3, within each social grade, the impact of disability on health is still very strong and especially strong in the lowest social grade, level 4.Therefore, we conclude that the variable health has a real and observable impact on marital status. The more severe the health problem, the higher the divorce rate.



# Logistic Regression
##A comprehensive regression analysis of all correlated variables

The variables presented thus far in this report are the variables hypothesised to have the greatest effect on a person's liklihood of being divorced in the sample. As the dependant variable in question is a dichotomous variable (divorced or not divorced), we built a logistic regression model and selected the variables discussed above as dependent variables. Our goal was to use the variables we examined to predict whether a person will be divorced. 

Overall, we experimented with a total of 8 variables to find the best Logistic Regression Model:
1. Social Grade
2. Education
3. Age
4. Religion
5. Health
6. Number of Children
7. Ethnicity
8. Whether the person lives in London

The best fit was determined by adding and removing the variables above until the best combination of the aforementioned metrics was obtained.
As a measure of the overall model's explanatory power, three main measures were use:
1) Misclassification Rate
2) c-statistic or AUC (area under ROC curve)
3) The accuracy of the predictions above a certain threshold (the mean divorce rate for our purposes)

In addition, we also examined the multicolinearity of our model to ensure its validity. 

In order to understand how good our model is, first we partitioned the original dataset into 70% training data and 30% test data. After we used the training data to train the model, we used the test data to compare our models.

```{r echo = FALSE}

census$ethnicityew <- factor(census$ethnicityew, levels = seq(1,18), labels = c("English/Welsh/Scottish/Northern Irish/British", 
"Irish", 
"Gypsy or Irish Traveller", 
"Other White", 
"Mixed/multiple ethnic group: White and Black Caribbean", 
"Mixed/multiple ethnic group: White and Black African", 
"Mixed/multiple ethnic group: White and Asian", 
"Mixed/multiple ethnic group: Other Mixed", 
"Indian", 
"Pakistani", 
"Bangladeshi", 
"Chinese", 
"Other Asian", 
"African", 
"Caribbean", 
"Other Black", 
"Arab", 
"Any other ethnic group"))

#1: white 2: Asian 3: black 4: Arab 5: other
census$ethngrouped <- census$ethnicityew
census$ethngrouped <- ifelse(census$ethnicityew == "English/Welsh/Scottish/Northern Irish/British"  | census$ethnicityew == "Irish" | census$ethnicityew == "Gypsy or Irish Traveller"| census$ethnicityew == "Other White", 1,       ifelse( census$ethnicityew == "Indian" | census$ethnicityew == "Pakistani"| census$ethnicityew == "Bangladeshi" | census$ethnicityew == "Chinese"| census$ethnicityew == "Other Asian", 2, 
                                        ifelse(census$ethnicityew == "African" | census$ethnicityew == "Caribbean"| census$ethnicityew == "Other Black", 3, 
                                               ifelse(census$ethnicityew == "Arab", 4, 
                                                      ifelse(census$ethnicityew == "other", "Any other ethnic group", 5)))))

```


```{r}
lr <- select(census, caseno, disability, marstat, hlqupuk11, scgpuk11c, religionew, age, region)
lr$separated <- lr$marstat
lr <- lr %>% mutate(separated = replace(separated, marstat == 2 | marstat == 3, 0))
lr <- lr %>% mutate(separated = replace(separated, marstat == 5 | marstat == 4, 1))
lr <- lr %>% mutate(london = ifelse(region == 10, 1, 0))
colnames(lr) <- c("ID", "disability", "marstat", "education", "social_grade", "religion", "age", "region", "separated", "london")
#replace -9 with NA 
lr <- lr %>% mutate_all(funs(replace(., . == -9, NA)))
lr <- lr %>% filter(!is.na(social_grade), !is.na(education), !(education == 16), !is.na(religion))

```

```{r echo = FALSE}
# Create training and validation dataset
input_ones <- lr[which(lr$separated == 1), ]  # all 1's
input_zeros <- lr[which(lr$separated == 0), ]  # all 0's
set.seed(100)  # for repeatability of samples
input_ones_training_rows <- sample(1:nrow(input_ones), 0.7*nrow(input_ones))  # 1's for training
input_zeros_training_rows <- sample(1:nrow(input_zeros), 0.7*nrow(input_zeros))  # 0's for training. Pick as many 0's as 1's
training_ones <- input_ones[input_ones_training_rows, ]  
training_zeros <- input_zeros[input_zeros_training_rows, ]
trainingData <- rbind(training_ones, training_zeros)  # row bind the 1's and 0's 

# Create Test Data
test_ones <- input_ones[-input_ones_training_rows, ]
test_zeros <- input_zeros[-input_zeros_training_rows, ]
testData <- rbind(test_ones, test_zeros)  # row bind the 1's and 0's 
```


```{r message = FALSE, echo = FALSE, result = "hide"}


library(smbinning)
library(InformationValue)

# use training data to train the model
#lin_mo1 <- glm(separated ~ social_grade + education + religion + age + london + children + ethnicity, data = trainingData, family = binomial)
#lin_mo2 <- glm(separated ~ social_grade + education + religion + age + london + disability + children +ethnicity, data = trainingData, family = binomial)
lin_mo1 <- glm(separated ~ social_grade + education, data = trainingData, family = binomial)
lin_mo2 <- glm(separated ~ social_grade + education + age, data = trainingData, family = binomial)

lin_mo3 <- glm(separated ~ social_grade + education + disability, data = trainingData, family = binomial(link = "logit"))
lin_mo4 <- glm(separated ~ social_grade + education + disability + age, data = trainingData, family = binomial(link = "logit"))
lin_mo5 <- glm(separated ~ social_grade, data = trainingData, family = binomial(link = "logit"))
l

# create predicted values and un-log it.
predicted1 <- predict(lin_mo1, testData, type = "response")
predicted2 <- plogis(predict(lin_mo2, testData))
predicted3 <- plogis(predict(lin_mo3, testData))
predicted4 <- plogis(predict(lin_mo4, testData))
predicted5 <- predict(lin_mo5, testData, type = "response")

Cutoff <- optimalCutoff(testData$separated, predicted3)


# manually testing the accuracy
pred <- ifelse(predicted3 > mean(as.numeric(testData$separated)), 1, 0)
 
# Calculate the model's accuracy
mean(testData$separated == pred)


# check for misclassification error
misClassError(testData$separated, predicted1)
# 0.4311, It should be a value between 0 and 1, the lower the better
misClassError(testData$separated, predicted2)
misClassError(testData$separated, predicted3, threshold = Cutoff)
misClassError(testData$separated, predicted4)
misClassError(testData$separated, predicted5)


plotROC(testData$separated, predicted5)
plotROC(testData$separated, predicted4)
plotROC(testData$separated, predicted3)
plotROC(testData$separated, predicted2)
plotROC(testData$separated, predicted1)







#library(stargazer)
#stargazer(list(lin_mo1,lin_mo2, lin_mo3),type = "text")
```
Based on our analysis, the best model contains 4 variables: Social Grade, Education, Health, and Age. These 4 variables are very likely to be the strongest drivers and predictors for divorce in the sample and the whole UK population. 
A close look on the ROC Curve 
```{r echo = FALSE}
lin_mo4 <- glm(separated ~ social_grade + education + disability + age , data = trainingData, family = binomial(link = "logit"))
predicted4 <- plogis(predict(lin_mo4, testData))
#misClassError(testData$separated, predicted4)
plotROC(testData$separated, predicted4)
```


```{r echo = FALSE}
# check for multicollinearity
library(car)
vif(lin_mo4) 
# as long as all values are below 4, it is fine, no big deal
```





# Conclusion

Our findings will go here

```{r Findings}

```

# References

Main Github Repository: https://github.com/dlouhasha/TheGreatWork

# Appendix
A list of all variables and descriptions